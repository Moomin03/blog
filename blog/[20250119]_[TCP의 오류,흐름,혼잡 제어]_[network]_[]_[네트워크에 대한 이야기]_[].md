### 💡 오류 제어: 재전송 기법


#### ✓ 오류 검출과 재전송
- TCP가 신뢰성을 제대로 보장하려면??
    - 송신 호스트가 송신한 세그먼트에 문제가 발생했음을 인지할 수 있어야함
    - 오류를 감지하게 되면 해당 세그먼트를 재전송할 수 있어야함
- 중복된 ACK 세그먼트를 수신했을때?
    - 수신 호스트 측이 받은 세그먼트의 순서 번호 중에서 일부가 누락되었다면 중복된 ACK 세그먼트를 전송하게 됨
    - RTT (Round Trip Time) : 메시지를 전송한 뒤 그에 대한 답변을 받는 데까지 걸리는 시간
- 타임아웃이 발생했을 때?
    - TCP는 타임아웃이 발생하면 문제가 생겼음을 인지
    - TCP 세그머트를 송신하는 호스트는 모두 **재전송 타이머** 라는 값을 유지함
    - 이 타이머의 카운트다운이 끝난 상황을 **타임아웃**이라고 함

#### ✓ ARQ: 재전송 기법
- 수신 호스트의 답변(ACK)과 타임아웃 발생을 토대로 문제를 진단하고, 문제가 생긴 메시지를 재전송함으로써 신뢰성을 확보하는 방식을 ARQ라고 함
    - Stop-and-Wait ARQ
        -> ARQ는 제대로 전달했음을 확인하기 전까지 새로운 메시지를 보내지 않는 방식
        -> 네트워크 이용 효율 낮아지고, 성능 저하로 이어짐
    - Go-Back-N ARQ
        -> 연속해서 메시지를 전송하는 기술을 **파이프라이닝**
        -> 파이프라이닝 방식을 활용해서 여러 세그먼트를 전송하고, 도중에 잘못된 전송 세그먼트에 대해서 해당 세그먼트부터 다시 전송
        -> 누적 확인 응답
    - Selective Repeat ARQ
        -> 송신 호스트는 올바르게 수신받지 못한 ACK 세그먼트가 있는지 검사하고, 응답받지 못한 세그먼트가 존재하면 재전송함
        -> 개별 확인 응답

#### ✓ 흐름제어: 슬라이딩 윈도우
> 수신 버퍼 : 수시된 세그먼트가 애플리케이션 프로세스에 의해 읽히기 저에 임시로 저장되는 공간
> 
> 버퍼 오버플로 : 버퍼가 넘치는 문제 상황
>
> TCP의 흐름제어란, 이러 상황을 방지하고자 송신 호스트가 수신 호스트의 처리 속도를 고려하며 송수신 속도를 균일하게 유지하는 것
> 
> 오늘날 TCP에서는 흐름제어로 **슬라이싱 윈도우**를 사용함
>
>> 윈도우란?
>>
>> 송시 호스트가 파이프라이닝할 수 있는 최대량 (윈도우 크기만큼 확인 응답을 받지 않고도 한 번에 전송 가능)

#### ✓ 혼잡이란?
> 혼잡이란 무엇일까?
>> 여러 호스트가 한 대의 라우터에 연결되어 있다고 가정해보면, 모든 호스트가 라우터에게 전송 가능한 최대의 양으로 세그먼트를 전송하면 라우터에 과부화가 생김
>>
>> 호스트들은 오류를 검출하여 재전송하게 되고, 라우터는 더 많은 세그먼트를 받게 되어 혼잡 현상이 악화됨

#### ✓ 혼잡 제어?
> 혼잡 윈도우의 크기는 호잡 제어 알고리즘을 통해 결정할 수 있음
>> AIMD (Additive Increase/Multiplicative Decreae)를 해석하면 합으로 증가, 곱으로 감소라는 의미
>>
>> 혼잡이 감지되지 않는다면 혼잡 윈도우를 RTT마다 1씩 선형적으로 증가시키고, 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 동작을 반복하는 알고리즘

- 느린 시작
    - 혼잡 윈도우를 1부터 시작해 문제 없이 수신된 ACK 세그먼트 하나 당 1씩 증가하는 방식 -> 지수적인 증가
    - 하지만 어제까지 지수적으로 증가시킬 수 없음
    - 느린 시작 알고리즘을 사용할 때 함께 사용하는 값으로 느린 시작 임계치 라는 값이 정해져있음
- 혼잡 회피
    - RTT마다 혼잡 윈도우를 1MSS씩 증가시키는 알고리즘
    - 선형적으로 증가함
- 빠른 회복
